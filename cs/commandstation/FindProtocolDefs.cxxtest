/** \copyright
 * Copyright (c) 2014-2016, Balazs Racz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are  permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \file FindProtocolDefs.cxxtest
 *
 * Tests for the static methods of the find train protocol.
 *
 * @author Balazs Racz
 * @date 2 Jul 2016
 */

#include "utils/test_main.hxx"
#include "commandstation/FindProtocolDefs.hxx"

namespace commandstation {
namespace {

string eventtohex(uint64_t event) { return StringPrintf("%016" PRIX64, event); }

string A2Q(unsigned address, bool exact, int mode) {
  return eventtohex(
      FindProtocolDefs::address_to_query(address, exact, (DccMode)mode));
}

string I2Q(const string& input) {
  return eventtohex(FindProtocolDefs::input_to_search(input));
}

string I2A(const string& input) {
  return eventtohex(FindProtocolDefs::input_to_allocate(input));
}

uint8_t match(const string& input, bool query, const string& name,
              unsigned address, DccMode mode) {
  auto event = query ? FindProtocolDefs::input_to_search(input)
                     : FindProtocolDefs::input_to_allocate(input);
  return FindProtocolDefs::match_query_to_train(event, name, address, mode);
}

TEST(AddressToQueryTest, simplexlate) {
  EXPECT_EQ("090099FFFFFF1300", A2Q(13, false, OLCBUSER));
  // Forced long
  EXPECT_EQ("090099FFFFFF1314", A2Q(13, false, DCC_LONG_ADDRESS | DCC_ANY));
  EXPECT_EQ("090099FF13572100", A2Q(135721, false, 0));
}

TEST(InputToQueryTest, simplexlate) {
  EXPECT_EQ("090099FFFFFF1300", I2Q("13"));
  // Forced long
  EXPECT_EQ("090099FFFFF01310", I2Q("013"));
  EXPECT_EQ("090099FFFF123400", I2Q("1234"));
  // some more exotic
  EXPECT_EQ("090099FF013F4110", I2Q("013 41"));
  EXPECT_EQ("090099FF013F4110", I2Q("013///41"));

  // Marklin
  EXPECT_EQ("090099FFFFF13F02", I2Q("13M"));
}

TEST(InputToAllocTest, simplexlate) {
  EXPECT_EQ("090099FFFFFF13C0", I2A("13"));
  // Forced long
  EXPECT_EQ("090099FFFFF013D0", I2A("013"));
  EXPECT_EQ("090099FFFFF13FD0", I2A("13L"));
  EXPECT_EQ("090099FFFF013FD0", I2A("013L"));
  EXPECT_EQ("090099FFFF1234C0", I2A("1234"));

  // Marklin
  EXPECT_EQ("090099FFFFF12FC2", I2A("12M"));
  EXPECT_EQ("090099FFFFF12FC1", I2A("12m"));
}

typedef FindProtocolDefs F;

TEST(MatchTest, testmatch) {
  EXPECT_EQ(0, match("13", true, "FooBar", 45, DCC_ANY));
  EXPECT_EQ(0, match("13", true, "FooBar", 4513, DCC_ANY));
  EXPECT_EQ(F::EXACT | F::MATCH_ANY,
            match("13", true, "FooBar13", 45, DCC_ANY));
  EXPECT_EQ(F::MATCH_ANY,
            match("13", true, "FooBar135", 45, DCC_ANY));
  EXPECT_EQ(F::EXACT | F::ADDRESS_ONLY | F::MATCH_ANY,
            match("13", true, "FooBar777", 13, DCC_128));

  EXPECT_EQ(F::ADDRESS_ONLY | F::MATCH_ANY,
            match("013", true, "FooBar777", 13, DCC_ANY));
  EXPECT_EQ(0, // allocate will not match due to short vs long
            match("013", false, "FooBar777", 13, DCC_ANY));

  EXPECT_EQ(0, // allocate will not match due to marklin vs dcc
            match("13M", false, "FooBar777", 13, DCC_ANY));
  EXPECT_NE(0, // this is marklin vs marklin
            match("13M", false, "FooBar777", 13, MARKLIN_NEW));
  
  EXPECT_EQ(F::EXACT | F::ADDRESS_ONLY | F::MATCH_ANY,
            match("013", true, "FooBar777", 13, DCC_14_LONG_ADDRESS));

  // Empty query should match all trains
  EXPECT_EQ(F::EXACT | F::ADDRESS_ONLY | F::MATCH_ANY,
            match("", true, "FooBar", 13, DCC_14_LONG_ADDRESS));
  EXPECT_EQ(F::EXACT | F::ADDRESS_ONLY | F::MATCH_ANY,
            match("", true, "FooBar777", 13, DCC_128));
}

TEST(MatchTest, longtoshortmatch) {
  // In this test we have a dcc long address locomotive and then a short
  // address allocate arrives. The match should fail.
  EXPECT_EQ(0, match("13", false, "013", 13, DCC_28_LONG_ADDRESS));

  // Another example in reverse: a short locomotive and a long address query.
  EXPECT_EQ(0, match("013", false, "13", 13, DCC_28));
}

TEST(MatchTest, marklinmatch) {
  // In this test we have a dcc long address locomotive and then a marklin
  // allocate arrives. The match should fail.
  EXPECT_EQ(0, match("13M", false, "013L", 13, DCC_28_LONG_ADDRESS));
  LOG(INFO, "2");
  // Another example: a short locomotive and a marklin query.
  EXPECT_EQ(0, match("13M", false, "13S", 13, DCC_28));

  // In this test we have a marklin-old locomotive and then a marklin address
  // allocate arrives.
  EXPECT_NE(0, match("13M", false, "13m", 13, MARKLIN_OLD));

  // Another example: a marklin-new loco and a marklin query.
  EXPECT_NE(0, match("13M", false, "13M", 13, MARKLIN_NEW));
}

}  // namespace
}  // namespace commandstation
