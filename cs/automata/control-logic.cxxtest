#include <unistd.h>

#include <string>
#include "gtest/gtest.h"
#include "gmock/gmock.h"

#include "control_logic_test_helper.hxx"
#include "../automata/control-logic.hxx"

using ::testing::HasSubstr;

extern int debug_variables;

namespace automata {

TEST_F(LogicTest, TestFramework) {
  static EventBasedVariable ev_var(
      &brd, "test", BRACZ_LAYOUT | 0xf000, BRACZ_LAYOUT | 0xf001, 0);
  static FakeBit input(this);
  DefAut(testaut, brd, {
    DefCopy(ImportVariable(input), ImportVariable(&ev_var));
  });
  EventListener listen_event(node_, ev_var);
  SetupRunner(&brd);
  Run();
  Run();

  input.Set(false);
  Run();
  EXPECT_FALSE(listen_event.value());

  input.Set(true);
  Run();
  EXPECT_TRUE(listen_event.value());
}

TEST_F(LogicTest, TestFramework2) {
  static EventBasedVariable ev_var(
      &brd, "test", BRACZ_LAYOUT | 0xf000, BRACZ_LAYOUT | 0xf001, 0);
  static FakeBit bout(this);
  DefAut(testaut2, brd, {
    DefCopy(ImportVariable(ev_var), ImportVariable(&bout));
  });
  SetupRunner(&brd);
  Run();
  Run();

  SetVar(ev_var, false);
  Run();
  EXPECT_FALSE(bout.Get());

  SetVar(ev_var, true);
  Run();
  EXPECT_TRUE(bout.Get());

  SetVar(ev_var, false);
  Run();
  EXPECT_FALSE(bout.Get());
}

TEST_F(LogicTest, TestFramework3) {
  std::unique_ptr<GlobalVariable> h(alloc()->Allocate("testbit"));
  std::unique_ptr<GlobalVariable> hh(alloc()->Allocate("testbit2"));
  static GlobalVariable* v = h.get();
  static GlobalVariable* w = hh.get();
  EventListener ldst(node_, *v);
  EventListener lsrc(node_, *w);
  DefAut(testaut2, brd, {
    DefCopy(ImportVariable(*w), ImportVariable(v));
  });
  SetupRunner(&brd);
  Run();
  Run();

  SetVar(*w, false);
  Run();
  EXPECT_FALSE(lsrc.value());
  EXPECT_FALSE(ldst.value());
 
  SetVar(*w, true);
  Run();
  EXPECT_TRUE(lsrc.value());
  EXPECT_TRUE(ldst.value());

  SetVar(*w, false);
  Run();
  EXPECT_FALSE(lsrc.value());
  EXPECT_FALSE(ldst.value());
}

TEST_F(LogicTest, SimulatedOccupancy_SingleShortPiece) {
  static StraightTrackShort piece(alloc()->Allocate("short", 80));
  FakeBit previous_detector(this);
  FakeBit next_detector(this);
  StraightTrackWithDetector before(
      alloc()->Allocate("before", 80), &previous_detector);
  StraightTrackWithDetector after(
      alloc()->Allocate("after", 80), &next_detector);
  piece.side_a()->Bind(before.side_b());
  piece.side_b()->Bind(after.side_a());

  EventListener sim_occ(node_, *piece.simulated_occupancy_);
  EventListener seen_train(node_, *piece.tmp_seen_train_in_next_);
  EventListener released(node_, *piece.side_b()->out_route_released);

  DefAut(strategyaut, brd, { piece.SimulateAllOccupancy(this); });

  EXPECT_FALSE(sim_occ.value());
  SetupRunner(&brd);
  Run();
  previous_detector.Set(true);
  next_detector.Set(false);
  Run();
  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(seen_train.value());
  SetVar(*piece.route_set_ab_, true);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_FALSE(seen_train.value());
  EXPECT_FALSE(released.value());
  // Now the train reaches the next detector.
  next_detector.Set(true);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(seen_train.value());
  // And then leaves the next detector.
  next_detector.Set(false);
  Run();
  EXPECT_TRUE(seen_train.value());
  EXPECT_TRUE(released.value());
  EXPECT_FALSE(sim_occ.value());
}

TEST_F(LogicTest, SimulatedOccupancy_MultipleShortPiece) {
  static StraightTrackShort piece(alloc()->Allocate("piece", 80));
  static StraightTrackShort piece2(alloc()->Allocate("piece2", 80));
  FakeBit previous_detector(this);
  FakeBit next_detector(this);
  StraightTrackWithDetector before(
      alloc()->Allocate("before", 80), &previous_detector);
  StraightTrackWithDetector after(
      alloc()->Allocate("after", 80), &next_detector);
  piece.side_a()->Bind(before.side_b());
  piece.side_b()->Bind(piece2.side_a());
  piece2.side_b()->Bind(after.side_a());

  EventListener sim_occ(node_, *piece.simulated_occupancy_);
  EventListener sim_occ2(node_, *piece2.simulated_occupancy_);

  DefAut(strategyaut, brd, {
    piece.SimulateAllOccupancy(this);
    piece2.SimulateAllOccupancy(this);
  });

  SetupRunner(&brd);
  Run();
  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());
  previous_detector.Set(true);
  next_detector.Set(false);
  Run();
  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());
  SetVar(*piece.route_set_ab_, true);
  SetVar(*piece2.route_set_ab_, true);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(sim_occ2.value());
  // Now the train reaches the next detector.
  next_detector.Set(true);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(sim_occ2.value());
  // And then leaves the next detector.
  next_detector.Set(false);
  Run();
  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());

  SetVar(*piece.route_set_ab_, false);
  SetVar(*piece2.route_set_ab_, false);
  previous_detector.Set(false);
  Run();

  // Now we go backwards!
  SetVar(*piece.route_set_ba_, true);
  SetVar(*piece2.route_set_ba_, true);
  next_detector.Set(true);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(sim_occ2.value());

  previous_detector.Set(true);
  Run();
  next_detector.Set(false);
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(sim_occ2.value());
  Run();
  previous_detector.Set(false);
  Run();
  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());
}

TEST_F(LogicTest, SimulatedOccupancy_ShortAndLongPieces) {
  static StraightTrackShort piece(alloc()->Allocate("p1", 32, 32));
  static StraightTrackShort piece2(alloc()->Allocate("p2", 32, 32));
  static StraightTrackLong piece3(alloc()->Allocate("p3", 32, 32));
  static StraightTrackShort piece4(alloc()->Allocate("p4", 32, 32));
  FakeBit previous_detector(this);
  FakeBit next_detector(this);
  StraightTrackWithDetector before(
      alloc()->Allocate("before", 80), &previous_detector);
  StraightTrackWithDetector after(
      alloc()->Allocate("after", 80), &next_detector);
  piece.side_a()->Bind(before.side_b());
  piece.side_b()->Bind(piece2.side_a());
  piece2.side_b()->Bind(piece3.side_a());
  piece3.side_b()->Bind(piece4.side_a());
  piece4.side_b()->Bind(after.side_a());

  EventListener sim_occ(node_, *piece.simulated_occupancy_);
  EventListener sim_occ2(node_, *piece2.simulated_occupancy_);
  EventListener sim_occ3(node_, *piece3.simulated_occupancy_);
  EventListener sim_occ4(node_, *piece4.simulated_occupancy_);

  DefAut(strategyaut, brd, {
    piece.SimulateAllOccupancy(this);
    piece2.SimulateAllOccupancy(this);
    piece3.SimulateAllOccupancy(this);
    piece4.SimulateAllOccupancy(this);
  });

  SetupRunner(&brd);

  EXPECT_EQ(&next_detector, piece4.side_b()->binding()->LookupNextDetector());
  EXPECT_EQ(&next_detector, piece3.side_b()->binding()->LookupNextDetector());
  EXPECT_EQ(&next_detector, piece2.side_b()->binding()->LookupFarDetector());

  EXPECT_EQ(&previous_detector,
            piece4.side_a()->binding()->LookupFarDetector());
  EXPECT_EQ(&previous_detector,
            piece3.side_a()->binding()->LookupNextDetector());

  // Now run the train forwards.
  SetVar(*piece.route_set_ab_, true);
  SetVar(*piece2.route_set_ab_, true);
  SetVar(*piece3.route_set_ab_, true);
  SetVar(*piece4.route_set_ab_, true);
  Run(3);
  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());
  EXPECT_FALSE(sim_occ3.value());
  EXPECT_FALSE(sim_occ4.value());

  previous_detector.Set(true);
  next_detector.Set(false);
  Run(3);

  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(sim_occ2.value());
  EXPECT_TRUE(QueryVar(*piece2.simulated_occupancy_));
  EXPECT_TRUE(sim_occ3.value());
  EXPECT_TRUE(QueryVar(*piece3.simulated_occupancy_));
  EXPECT_TRUE(sim_occ4.value());
  EXPECT_TRUE(QueryVar(*piece4.simulated_occupancy_));

  previous_detector.Set(false);
  next_detector.Set(true);
  Run(3);

  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());
  EXPECT_TRUE(sim_occ3.value());
  EXPECT_TRUE(sim_occ4.value());

  next_detector.Set(false);
  Run(3);

  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());
  EXPECT_FALSE(sim_occ3.value());
  EXPECT_FALSE(sim_occ4.value());

  // Run backwards.
  SetVar(*piece.route_set_ab_, false);
  SetVar(*piece2.route_set_ab_, false);
  SetVar(*piece3.route_set_ab_, false);
  SetVar(*piece4.route_set_ab_, false);
  Run();
  SetVar(*piece.route_set_ba_, true);
  SetVar(*piece2.route_set_ba_, true);
  SetVar(*piece3.route_set_ba_, true);
  SetVar(*piece4.route_set_ba_, true);
  Run();

  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(sim_occ2.value());
  EXPECT_FALSE(sim_occ3.value());
  EXPECT_FALSE(sim_occ4.value());

  next_detector.Set(true);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(sim_occ2.value());
  EXPECT_TRUE(sim_occ3.value());
  EXPECT_TRUE(sim_occ4.value());

  next_detector.Set(false);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(sim_occ2.value());
  EXPECT_TRUE(sim_occ3.value());
  EXPECT_TRUE(sim_occ4.value());

  previous_detector.Set(true);
  Run();
  EXPECT_TRUE(sim_occ.value());
  EXPECT_TRUE(QueryVar(*piece.simulated_occupancy_));
  EXPECT_TRUE(sim_occ2.value());
  EXPECT_TRUE(sim_occ3.value());
  EXPECT_FALSE(sim_occ4.value());

  previous_detector.Set(false);
  Run();
  EXPECT_FALSE(sim_occ.value());
  EXPECT_FALSE(QueryVar(*piece.simulated_occupancy_));
  EXPECT_FALSE(sim_occ2.value());
  EXPECT_FALSE(sim_occ3.value());
  EXPECT_FALSE(sim_occ4.value());
}

TEST_F(LogicTest, SimulatedOccupancy_RouteSetting) {
  static StraightTrackShort piece(alloc()->Allocate("p", 32, 32));
  FakeBit previous_detector(this);
  FakeBit next_detector(this);
  StraightTrackWithDetector before(
      alloc()->Allocate("before", 32, 32), &previous_detector);
  StraightTrackWithDetector after(
      alloc()->Allocate("after", 32, 32), &next_detector);

  piece.side_a()->Bind(before.side_b());
  piece.side_b()->Bind(after.side_a());

  DefAut(strategyaut, brd, {
    piece.SimulateAllOccupancy(this);
    piece.SimulateAllRoutes(this);
    HandleInitState(this);
  });

  SetupRunner(&brd);

  Run();
  Run();

  EXPECT_EQ(StBase.state, runner_->GetAllAutomatas()[0]->GetState());

  EXPECT_FALSE(QueryVar(*piece.route_set_ba_));
  EXPECT_FALSE(QueryVar(*piece.route_set_ab_));
  EXPECT_FALSE(QueryVar(*piece.tmp_route_setting_in_progress_));
  // An incoming route request here.
  SetVar(*before.side_b()->out_try_set_route, true);

  Run();

  // Should be propagated.
  EXPECT_TRUE(QueryVar(*piece.side_b()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*piece.side_a()->in_route_set_success));
  EXPECT_TRUE(QueryVar(*piece.tmp_route_setting_in_progress_));

  Run();
  EXPECT_TRUE(QueryVar(*piece.tmp_route_setting_in_progress_));
  EXPECT_FALSE(QueryVar(*before.side_b()->out_try_set_route));
  Run();

  EXPECT_EQ(after.side_a()->binding(), piece.side_b());
  EXPECT_EQ(before.side_b()->binding(), piece.side_a());
  EXPECT_EQ(after.side_a(), piece.side_b()->binding());
  EXPECT_EQ(before.side_b(), piece.side_a()->binding());
  EXPECT_TRUE(QueryVar(*after.side_a()->binding()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*before.side_b()->binding()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*before.side_b()->binding()->in_route_set_failure));
  EXPECT_TRUE(QueryVar(*piece.tmp_route_setting_in_progress_));
  EXPECT_FALSE(QueryVar(*piece.simulated_occupancy_));
  EXPECT_FALSE(QueryVar(*piece.route_set_ab_));
  EXPECT_FALSE(QueryVar(*piece.route_set_ba_));

  SetVar(*after.side_a()->in_route_set_success, true);
  SetVar(*after.side_a()->binding()->out_try_set_route, false);
  Run();
  Run();

  EXPECT_FALSE(QueryVar(*piece.tmp_route_setting_in_progress_));
  EXPECT_FALSE(SQueryVar(*after.side_a()->binding()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*before.side_b()->binding()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*before.side_b()->binding()->in_route_set_failure));
  EXPECT_FALSE(QueryVar(*before.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*piece.route_set_ab_));
  EXPECT_FALSE(QueryVar(*piece.route_set_ba_));

  // Now a second route setting should fail.
  SetVar(*before.side_b()->out_try_set_route, true);

  Run();
  Run();

  EXPECT_FALSE(QueryVar(*before.side_b()->out_try_set_route));
  EXPECT_FALSE(SQueryVar(*before.side_b()->binding()->in_route_set_success));
  EXPECT_TRUE(QueryVar(*before.side_b()->binding()->in_route_set_failure));

  // And an opposite route should fail too.
  SetVar(*after.side_a()->out_try_set_route, true);

  Run();
  Run();

  EXPECT_FALSE(QueryVar(*after.side_a()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*after.side_a()->binding()->in_route_set_success));
  EXPECT_TRUE(QueryVar(*after.side_a()->binding()->in_route_set_failure));
}
TEST_F(LogicTest, ReverseRoute) {
  static StraightTrackShort piece(alloc()->Allocate("piece", 80));
  FakeBit previous_detector(this);
  FakeBit next_detector(this);
  StraightTrackWithDetector before(
      alloc()->Allocate("before", 80), &previous_detector);
  StraightTrackWithDetector after(
      alloc()->Allocate("after", 80), &next_detector);

  piece.side_a()->Bind(before.side_b());
  piece.side_b()->Bind(after.side_a());

  DefAut(strategyaut, brd, {
    piece.SimulateAllOccupancy(this);
    piece.SimulateAllRoutes(this);
    HandleInitState(this);
  });

  SetupRunner(&brd);

  Run();
  Run();

  // An incoming route request here.
  SetVar(*after.side_a()->out_try_set_route, true);

  Run();

  // Debug
  EXPECT_FALSE(QueryVar(*before.side_b()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*piece.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*piece.tmp_route_setting_in_progress_));
  EXPECT_FALSE(QueryVar(*piece.route_pending_ab_));
  EXPECT_TRUE(QueryVar(*piece.route_pending_ba_));

  // Should be propagated.
  EXPECT_TRUE(QueryVar(*piece.side_a()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*piece.side_b()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*piece.side_b()->in_route_set_failure));

  Run();

  SetVar(*before.side_b()->in_route_set_success, true);
  SetVar(*before.side_b()->binding()->out_try_set_route, false);
  Run();
  Run();

  EXPECT_TRUE(SQueryVar(*piece.side_b()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*piece.side_b()->in_route_set_failure));
  EXPECT_TRUE(QueryVar(*piece.route_set_ba_));
  EXPECT_FALSE(QueryVar(*piece.route_set_ab_));
}

TEST_F(LogicTest, SimulatedOccupancy_SimultSetting) {
  static StraightTrackShort piece(alloc()->Allocate("piece", 80));
  FakeBit previous_detector(this);
  FakeBit next_detector(this);
  StraightTrackWithDetector before(
      alloc()->Allocate("before", 80), &previous_detector);
  StraightTrackWithDetector after(
      alloc()->Allocate("after", 80), &next_detector);

  piece.side_a()->Bind(before.side_b());
  piece.side_b()->Bind(after.side_a());

  DefAut(strategyaut, brd, {
    piece.RunAll(this);
    //piece.SimulateAllOccupancy(this);
    //piece.SimulateAllRoutes(this);
  });

  SetupRunner(&brd);

  Run();
  Run();

  // An incoming route request here.
  SetVar(*after.side_a()->out_try_set_route, true);
  Run();

  // Should be propagated.
  EXPECT_TRUE(SQueryVar(*piece.side_a()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*piece.side_b()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*piece.side_b()->in_route_set_failure));
  EXPECT_TRUE(QueryVar(*piece.tmp_route_setting_in_progress_));
  EXPECT_FALSE(QueryVar(*after.side_a()->out_try_set_route));
  Run();

  // A conflicting route request,
  SetVar(*before.side_b()->out_try_set_route, true);
  Run();
  // which is rejected immediately.
  EXPECT_FALSE(QueryVar(*before.side_b()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*before.side_b()->binding()->in_route_set_success));
  EXPECT_TRUE(QueryVar(*before.side_b()->binding()->in_route_set_failure));

  // Then the first route set request returns.
  SetVar(*before.side_b()->in_route_set_success, true);
  SetVar(*before.side_b()->binding()->out_try_set_route, false);
  Run();

  // And then the first route sets properly.
  EXPECT_TRUE(QueryVar(*after.side_a()->binding()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*after.side_a()->binding()->in_route_set_failure));
  EXPECT_FALSE(QueryVar(*after.side_a()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*piece.route_set_ba_));
  EXPECT_FALSE(QueryVar(*piece.route_set_ab_));
}

TEST_F(LogicTest, MultiRoute) {
  static StraightTrackShort piece(alloc()->Allocate("piece", 80));
  static StraightTrackShort piece2(alloc()->Allocate("piece2", 80));
  static StraightTrackLong piece3(alloc()->Allocate("piece3", 80));
  static StraightTrackShort piece4(alloc()->Allocate("piece4", 80));
  FakeBit previous_detector(this);
  FakeBit next_detector(this);
  static StraightTrackWithDetector before(
      alloc()->Allocate("before", 80), &previous_detector);
  static StraightTrackWithDetector after(
      alloc()->Allocate("after", 80), &next_detector);
  piece.side_a()->Bind(before.side_b());
  piece.side_b()->Bind(piece2.side_a());
  piece2.side_b()->Bind(piece3.side_a());
  piece3.side_b()->Bind(piece4.side_a());
  piece4.side_b()->Bind(after.side_a());

#define DefPiece(pp)               \
  DefAut(aut##pp, brd, {           \
    pp.SimulateAllOccupancy(this); \
    pp.SimulateAllRoutes(this);    \
    HandleInitState(this);         \
  })

  DefPiece(piece);
  DefPiece(piece2);
  DefPiece(piece3);
  DefPiece(piece4);
#undef DefPiece

  // This will immediately accept a route at the end stop.
  DefAut(strategyaut, brd, {
    LocalVariable* try_set_route =
        ImportVariable(after.side_a()->binding()->out_try_set_route.get());
    LocalVariable* route_set_succcess =
        ImportVariable(after.side_a()->in_route_set_success.get());
    Def().IfReg1(*try_set_route).ActReg0(try_set_route).ActReg1(
        route_set_succcess);
  });

  SetupRunner(&brd);

  Run(10);
  SetVar(*before.side_b()->out_try_set_route, true);
  Run(10);
  EXPECT_FALSE(QueryVar(*before.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*before.side_b()->binding()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*before.side_b()->binding()->in_route_set_failure));

  SetVar(*before.side_b()->binding()->in_route_set_success, false);
  Run(10);

  // Now we run the route.
  previous_detector.Set(true);
  Run(10);
  previous_detector.Set(false);
  Run(10);
  next_detector.Set(true);
  Run(10);
  next_detector.Set(false);
  Run(10);

  EXPECT_FALSE(SQueryVar(*piece.simulated_occupancy_));
  EXPECT_FALSE(SQueryVar(*piece.route_set_ab_));

  // Route should be done, we set another one.
  Run(10);
  SetVar(*before.side_b()->out_try_set_route, true);
  Run(10);
  EXPECT_FALSE(QueryVar(*before.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*before.side_b()->binding()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*before.side_b()->binding()->in_route_set_failure));
}


TEST_F(LogicTest, Signal0) {
  FakeBit previous_detector(this);
  FakeBit request_green(this);
  FakeBit signal_green(this);
  FakeBit route_no_stop(this);
  FakeBit next_detector(this);
  FakeBit request_green2(this);
  FakeBit signal_green2(this);
  FakeBit route_no_stop2(this);
  static StraightTrackLong first_body(alloc()->Allocate("first_body", 80));
  static StraightTrackWithDetector first_det(
      alloc()->Allocate("first_det", 80), &previous_detector);
  static SignalPiece signal(alloc()->Allocate("signal", 80), &request_green,
                            &signal_green, &route_no_stop);
  static StraightTrackLong mid(alloc()->Allocate("mid", 80));
  static StraightTrackLong second_body(alloc()->Allocate("second_body", 80));
  static StraightTrackWithDetector second_det(
      alloc()->Allocate("second_det", 80), &next_detector);
  static SignalPiece second_signal(alloc()->Allocate("second_signal", 80),
                                   &request_green2, &signal_green2,
                                   &route_no_stop2);
  static StraightTrackLong after(alloc()->Allocate("after", 80));

  BindSequence({&first_body,    &first_det,   &signal,
          &mid,           &second_body, &second_det,
          &second_signal, &after});

#define DefPiece(pp) \
  DefAut(aut##pp, brd, { pp.RunAll(this); })

  DefPiece(first_det);
  DefPiece(mid);
  DefPiece(signal);
  DefPiece(second_body);
  DefPiece(second_det);
  DefPiece(second_signal);

#undef DefPiece

  // This will immediately accept a route at the end stop.
  DefAut(strategyaut, brd, {
    LocalVariable* try_set_route =
        ImportVariable(after.side_a()->binding()->out_try_set_route.get());
    LocalVariable* route_set_succcess =
        ImportVariable(after.side_a()->in_route_set_success.get());
    Def().IfReg1(*try_set_route).ActReg0(try_set_route).ActReg1(
        route_set_succcess);
  });

  SetupRunner(&brd);
  Run(2);

  // Sets the first train's route until the first signal.
  SetVar(*first_body.side_b()->out_try_set_route, true);
  Run(5);
  EXPECT_FALSE(QueryVar(*first_body.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*first_body.side_b()->binding()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*first_body.side_b()->binding()->in_route_set_failure));

  EXPECT_TRUE(QueryVar(*first_det.route_set_ab_));
  // the route is not yet beyond the signal
  EXPECT_FALSE(QueryVar(*signal.route_set_ab_)); 
  EXPECT_FALSE(signal_green.Get());

  // First train shows up at first signal.
  previous_detector.Set(true);
  Run(5);
  EXPECT_TRUE(QueryVar(*first_det.route_set_ab_));
  EXPECT_FALSE(signal_green.Get());

  EXPECT_FALSE(QueryVar(*signal.route_set_ab_));
  EXPECT_FALSE(QueryVar(*mid.route_set_ab_));

  // and gets a green
  request_green.Set(true);
  Run(1);
  EXPECT_TRUE(request_green.Get());
  EXPECT_TRUE(QueryVar(*signal.side_b()->out_try_set_route));
  Run(10);

  EXPECT_FALSE(request_green.Get());
  EXPECT_TRUE(QueryVar(*mid.route_set_ab_));
  EXPECT_TRUE(QueryVar(*signal.route_set_ab_));
  EXPECT_TRUE(signal_green.Get());

  // Checks that signal green gets reset.
  signal_green.Set(false);
  EXPECT_FALSE(signal_green.Get());
  Run(5);
  EXPECT_TRUE(QueryVar(*signal.route_set_ab_));
  EXPECT_TRUE(signal_green.Get());

  // and leaves the block
  previous_detector.Set(false);
  Run(10);
  EXPECT_TRUE(QueryVar(*mid.route_set_ab_));
  EXPECT_FALSE(QueryVar(*signal.route_set_ab_));
  EXPECT_FALSE(QueryVar(*first_det.route_set_ab_));
  EXPECT_FALSE(signal_green.Get());

  EXPECT_FALSE(QueryVar(*first_body.side_b()->out_try_set_route));

  // We run a second route until the first signal
  SetVar(*first_body.side_b()->out_try_set_route, true);
  Run(5);
  // let's dump all bits that are set
  for (int c = 0; c < 256; c++) {
    int client, offset, bit;
    DecodeOffset(c, &client, &offset, &bit);
    if ((1 << bit) & *get_state_byte(client, offset)) {
      printf("bit %d [%d * 32 + %d * 8 + %d] (c %d o %d bit %d)\n",
             c,
             c / 32,
             (c % 32) / 8,
             c % 8,
             client,
             offset,
             bit);
    }
  }

  EXPECT_FALSE(QueryVar(*signal.route_set_ab_));
  EXPECT_FALSE(signal_green.Get());
  EXPECT_TRUE(QueryVar(*first_det.route_set_ab_));

  // We try to set another green, but the previous train blocks this.
  request_green.Set(true);
  Run(1);
  EXPECT_TRUE(request_green.Get());
  EXPECT_TRUE(QueryVar(*signal.side_b()->out_try_set_route));
  Run(10);

  EXPECT_FALSE(request_green.Get());
  EXPECT_FALSE(QueryVar(*signal.side_b()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*signal.route_set_ab_));
  EXPECT_FALSE(signal_green.Get());

  // First train reaches second signal.
  next_detector.Set(true);
  request_green.Set(true);
  Run(10);
  EXPECT_FALSE(QueryVar(*mid.route_set_ab_));
  EXPECT_TRUE(QueryVar(*second_det.route_set_ab_));
  EXPECT_FALSE(QueryVar(*second_signal.route_set_ab_));
  EXPECT_FALSE(signal_green2.Get());

  EXPECT_FALSE(request_green.Get());
  EXPECT_FALSE(signal_green.Get());

  request_green2.Set(true);
  Run(5);
  EXPECT_TRUE(signal_green2.Get());
  EXPECT_TRUE(QueryVar(*second_signal.route_set_ab_));

  next_detector.Set(false);
  Run(10);
  EXPECT_FALSE(signal_green2.Get());
  EXPECT_FALSE(QueryVar(*second_signal.route_set_ab_));

  // Now the second train can go.
  request_green.Set(true);
  Run(10);
  EXPECT_FALSE(request_green.Get());
  EXPECT_TRUE(signal_green.Get());
  EXPECT_TRUE(QueryVar(*signal.route_set_ab_));
  EXPECT_TRUE(QueryVar(*mid.route_set_ab_));
}


TEST_F(LogicTest, Signal) {
  TestDetectorBlock before(this, "before");
  static StraightTrackLong mid(alloc()->Allocate("mid", 80));
  DefAut(autmid, brd, { mid.RunAll(this); });
  TestBlock first(this, "first");
  TestBlock second(this, "second");
  static StraightTrackLong after(alloc()->Allocate("after", 80));

  BindSequence({&before.b, first.b(), &mid, second.b(), &after});

  ASSERT_EQ(first.b()->signal_.side_b(), mid.side_a()->binding());


  // This will immediately accept a route at the end stop.
  DefAut(strategyaut, brd, {
    LocalVariable* try_set_route =
        ImportVariable(after.side_a()->binding()->out_try_set_route.get());
    LocalVariable* route_set_succcess =
        ImportVariable(after.side_a()->in_route_set_success.get());
    Def().IfReg1(*try_set_route).ActReg0(try_set_route).ActReg1(
        route_set_succcess);
  });

  SetupRunner(&brd);

  // No trains initially.
  first.inverted_detector()->Set(true);
  second.inverted_detector()->Set(true);
  Run(1);

  // No trains initially.
  first.inverted_detector()->Set(true);
  second.inverted_detector()->Set(true);
  Run(20);
  EXPECT_FALSE(QueryVar(*first.b()->body_det_.simulated_occupancy_));
  EXPECT_FALSE(QueryVar(*second.b()->body_det_.simulated_occupancy_));


  // Sets the first train's route until the first signal.
  LOG(INFO, "Setting route to first signal.");
  before.detector.Set(true);
  SetVar(*before.b.side_b()->out_try_set_route, true);
  Run(10);
  EXPECT_FALSE(QueryVar(*before.b.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*first.b()->side_a()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*first.b()->side_a()->in_route_set_failure));

  EXPECT_TRUE(QueryVar(*first.b()->body_det_.route_set_ab_));
  // the route is not yet beyond the signal
  EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_FALSE(first.signal_green()->Get());

  EXPECT_FALSE(QueryVar(*first.b()->body_det_.simulated_occupancy_));
  // First train shows up at first signal.
  LOG(INFO, "First train shows up at first signal.");
  before.detector.Set(false);
  Run(1);
  first.inverted_detector()->Set(false);
  Run(12);
  EXPECT_TRUE(QueryVar(*first.b()->body_det_.simulated_occupancy_));

  EXPECT_TRUE(QueryVar(*first.b()->body_det_.route_set_ab_));
  EXPECT_FALSE(first.signal_green()->Get());

  EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_FALSE(QueryVar(*mid.route_set_ab_));

  // and gets a green
  LOG(INFO, "First train gets a green at first signal.");
  SetVar(*first.b()->request_green(), true);
  Run(1);
  EXPECT_TRUE(QueryVar(*first.b()->request_green()));
  EXPECT_TRUE(QueryVar(*first.b()->signal_.side_b()->out_try_set_route));
  Run(10);
  EXPECT_FALSE(QueryVar(*first.b()->signal_.side_b()->out_try_set_route));

  EXPECT_FALSE(QueryVar(*first.b()->request_green()));
  EXPECT_TRUE(QueryVar(*mid.route_set_ab_));
  EXPECT_TRUE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_TRUE(first.signal_green()->Get());

  // Checks that signal green gets reset.
  first.signal_green()->Set(false);
  EXPECT_FALSE(first.signal_green()->Get());
  Run(5);
  EXPECT_TRUE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_TRUE(first.signal_green()->Get());


  EXPECT_TRUE(QueryVar(*first.b()->body_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*first.b()->body_det_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*first.b()->body_.simulated_occupancy_));


  EXPECT_TRUE(QueryVar(*first.b()->body_det_.simulated_occupancy_));
  // and leaves the block
  LOG(INFO, "train left first block.");
  first.inverted_detector()->Set(true);
  Run(15);
  EXPECT_FALSE(QueryVar(*first.b()->body_.simulated_occupancy_));
  EXPECT_FALSE(QueryVar(*first.b()->body_det_.simulated_occupancy_));
  EXPECT_FALSE(QueryVar(*first.b()->signal_.simulated_occupancy_));
  EXPECT_TRUE(QueryVar(*mid.route_set_ab_));
  EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_FALSE(QueryVar(*first.b()->body_det_.route_set_ab_));
  EXPECT_FALSE(QueryVar(*first.b()->body_.route_set_ab_));
  EXPECT_FALSE(first.signal_green()->Get());

  EXPECT_FALSE(QueryVar(*first.b()->body_.side_b()->out_try_set_route));

  // We run a second route until the first signal
  LOG(INFO, "Second train: sets route to first signal.");
  before.detector.Set(true);
  Run(4);
  SetVar(*first.b()->body_.side_b()->out_try_set_route, true);
  Run(5);
  // let's dump all bits that are set
  for (int c = 0; c < 256; c++) {
    int client, offset, bit;
    DecodeOffset(c, &client, &offset, &bit);
    if ((1 << bit) & *get_state_byte(client, offset)) {
      printf("bit %d [%d * 32 + %d * 8 + %d] (c %d o %d bit %d)\n",
             c,
             c / 32,
             (c % 32) / 8,
             c % 8,
             client,
             offset,
             bit);
    }
  }

  EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_FALSE(first.signal_green()->Get());
  EXPECT_TRUE(QueryVar(*first.b()->body_det_.route_set_ab_));

  // We try to set another green, but the previous train blocks this.
  LOG(INFO, "Second train: try get green (and fail).");
  SetVar(*first.b()->request_green(), true);
  Run(1);
  EXPECT_TRUE(QueryVar(*first.b()->request_green()));
  EXPECT_TRUE(QueryVar(*first.b()->signal_.side_b()->out_try_set_route));
  Run(10);

  EXPECT_FALSE(QueryVar(*first.b()->request_green()));
  EXPECT_FALSE(QueryVar(*first.b()->signal_.side_b()->out_try_set_route));
  EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_FALSE(first.signal_green()->Get());

  // First train reaches second signal.
  LOG(INFO, "First train reaches second signal and first train tries to get green again(fail).");
  second.inverted_detector()->Set(false);
  SetVar(*first.b()->request_green(), true);
  Run(14);
  EXPECT_FALSE(QueryVar(*mid.route_set_ab_));
  EXPECT_TRUE(QueryVar(*second.b()->body_det_.route_set_ab_));
  EXPECT_FALSE(QueryVar(*second.b()->signal_.route_set_ab_));
  EXPECT_FALSE(second.signal_green()->Get());

  EXPECT_FALSE(QueryVar(*first.b()->request_green()));
  EXPECT_FALSE(first.signal_green()->Get());

  debug_variables = 2;

  LOG(INFO, "First train gets green at second signal.");
  SetVar(*second.b()->request_green(), true);
  Run(5);
  EXPECT_TRUE(second.signal_green()->Get());
  EXPECT_TRUE(QueryVar(*second.b()->signal_.route_set_ab_));

  LOG(INFO, "First train leaves from second signal.");
  second.inverted_detector()->Set(true);
  Run(10);
  EXPECT_FALSE(second.signal_green()->Get());
  EXPECT_FALSE(QueryVar(*second.b()->signal_.route_set_ab_));

  // Now the second train can go.
  // We shortcut the second signal.
  LOG(INFO, "Shortcut second signal.");
  SetVar(*second.b()->signal_no_stop(), true);
  Run(10);
  
  LOG(INFO, "Second train gets green to the end.");
  first.inverted_detector()->Set(false);
  SetVar(*first.b()->request_green(), true);
  Run(20);
  EXPECT_FALSE(QueryVar(*first.b()->request_green()));
  EXPECT_TRUE(first.signal_green()->Get());
  EXPECT_TRUE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*mid.route_set_ab_));
  EXPECT_TRUE(QueryVar(*second.b()->signal_.route_set_ab_));

  LOG(INFO, "Second train leaves first.");
  first.inverted_detector()->Set(true);
  Run(20);
  EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_FALSE(first.signal_green()->Get());
  EXPECT_TRUE(second.signal_green()->Get());

  LOG(INFO, "Second train gets to second signal.");
  second.inverted_detector()->Set(false);
  Run(20);
  EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
  EXPECT_FALSE(first.signal_green()->Get());
  EXPECT_TRUE(second.signal_green()->Get());
  EXPECT_TRUE(QueryVar(*second.b()->signal_.route_set_ab_));

  LOG(INFO, "Second train leaves second signal.");
  second.inverted_detector()->Set(true);
  Run(20);
  EXPECT_FALSE(first.signal_green()->Get());
  EXPECT_FALSE(second.signal_green()->Get());
  EXPECT_FALSE(QueryVar(*second.b()->signal_.route_set_ab_));

  LOG(INFO, "Tests running a third train.");
  SetVar(*first.b()->signal_no_stop(), true);

  SetVar(*before.b.side_b()->out_try_set_route, true);
  Run(20);
  EXPECT_FALSE(QueryVar(*before.b.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*first.b()->side_a()->in_route_set_success));
  EXPECT_FALSE(QueryVar(*first.b()->side_a()->in_route_set_failure));
  EXPECT_TRUE(first.signal_green()->Get());
  EXPECT_TRUE(second.signal_green()->Get());
}

//              ------station_lr>>---
// ----left>---/----<<station_rl-----\----<right---

TEST_F(LogicTest, FixedTurnout) {
  static TestDetectorBlock end_left(this, "end_left");
  static TestDetectorBlock end_right(this, "end_right");
  TestShortTrack mid_left(this, "mid_left");
  TestShortTrack mid_right(this, "mid_right");
  TestBlock left(this, "left");
  TestBlock right(this, "right");
  TestBlock station_lr(this, "station_lr");
  TestBlock station_rl(this, "station_rl");
  TestFixedTurnout turnout_l(this, FixedTurnout::TURNOUT_THROWN, "turnout_l");
  TestFixedTurnout turnout_r(this, FixedTurnout::TURNOUT_CLOSED, "turnout_r");

  BindSequence({&end_left.b, &mid_left.b, left.b()});
  BindSequence({&end_right.b, &mid_right.b, right.b()});
  left.b()->side_b()->Bind(turnout_l.b.side_points());
  right.b()->side_b()->Bind(turnout_r.b.side_points());

  station_lr.b()->side_a()->Bind(turnout_l.b.side_thrown());
  station_lr.b()->side_b()->Bind(turnout_r.b.side_thrown());

  station_rl.b()->side_b()->Bind(turnout_l.b.side_closed());
  station_rl.b()->side_a()->Bind(turnout_r.b.side_closed());

  // This will immediately accept a route at the end stop.
  DefAut(strategyaut, brd, {
    LocalVariable* try_set_route =
        ImportVariable(end_left.b.side_b()->binding()->out_try_set_route.get());
    LocalVariable* route_set_succcess =
        ImportVariable(end_left.b.side_b()->in_route_set_success.get());
    Def().IfReg1(*try_set_route).ActReg0(try_set_route).ActReg1(
        route_set_succcess);
    try_set_route = ImportVariable(
        end_right.b.side_b()->binding()->out_try_set_route.get());
    route_set_succcess =
        ImportVariable(end_right.b.side_b()->in_route_set_success.get());
    Def().IfReg1(*try_set_route).ActReg0(try_set_route).ActReg1(
        route_set_succcess);
  });

  SetupRunner(&brd);
  // No trains anywhere.
  end_left.detector.Set(false);
  end_right.detector.Set(false);
  left.inverted_detector()->Set(true);
  right.inverted_detector()->Set(true);
  station_lr.inverted_detector()->Set(true);
  station_rl.inverted_detector()->Set(true);
  Run(1);
  left.inverted_detector()->Set(true);
  right.inverted_detector()->Set(true);
  station_lr.inverted_detector()->Set(true);
  station_rl.inverted_detector()->Set(true);
  Run(15);

  EXPECT_FALSE(QueryVar(*left.b()->body_det_.simulated_occupancy_));

  // Source a train from left and right.
  end_left.detector.Set(true);
  end_right.detector.Set(true);
  SetVar(*end_left.b.side_b()->out_try_set_route, true);
  SetVar(*end_right.b.side_b()->out_try_set_route, true);
  Run(12);
  EXPECT_FALSE(QueryVar(*end_left.b.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*end_left.b.side_b()->binding()->in_route_set_success));
  EXPECT_TRUE(QueryVar(*left.b()->body_det_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*mid_left.b.route_set_ab_));
  EXPECT_FALSE(QueryVar(*end_right.b.side_b()->out_try_set_route));
  EXPECT_TRUE(QueryVar(*end_right.b.side_b()->binding()->in_route_set_success));
  EXPECT_TRUE(QueryVar(*mid_right.b.route_set_ab_));
  EXPECT_TRUE(QueryVar(*right.b()->body_det_.route_set_ab_));

  // Both trains reach their stops on open track outside of the station.
  end_left.detector.Set(false);
  end_right.detector.Set(false);
  left.inverted_detector()->Set(false);
  right.inverted_detector()->Set(false);
  Run(12);

  EXPECT_FALSE(QueryVar(*mid_left.b.route_set_ab_));
  EXPECT_FALSE(QueryVar(*mid_right.b.route_set_ab_));

  EXPECT_FALSE(QueryVar(*left.b()->signal_.route_set_ab_));
  EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));

  // Give them green.
  LOG(INFO, "Giving green to left train");
  EXPECT_TRUE(QueryVar(*turnout_l.b.turnout_state_));
  EXPECT_FALSE(QueryVar(*turnout_r.b.turnout_state_));
  SetVar(*left.b()->request_green(), true);
  Run(10);
  EXPECT_TRUE(left.signal_green()->Get());
  EXPECT_TRUE(QueryVar(*left.b()->signal_.route_set_ab_));
  EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));

  EXPECT_TRUE(QueryVar(*left.b()->signal_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*turnout_l.b.route_set_PT_));
  EXPECT_TRUE(QueryVar(*turnout_l.b.any_route_set_));

  EXPECT_FALSE(QueryVar(*turnout_r.b.any_route_set_));
  EXPECT_TRUE(QueryVar(*station_lr.b()->body_det_.route_set_ab_));

  left.inverted_detector()->Set(true);
  Run(15);

  EXPECT_FALSE(QueryVar(*left.b()->body_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*turnout_l.b.any_route_set_));

  // Arrives in the station.
  station_lr.inverted_detector()->Set(false);
  Run(15);

  EXPECT_FALSE(QueryVar(*left.b()->signal_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*station_lr.b()->body_.route_set_ab_));
  EXPECT_FALSE(QueryVar(*turnout_l.b.any_route_set_));

  // But cannot go out to the right because there is a train there.
  SetVar(*station_lr.b()->request_green(), true);
  Run(10);
  EXPECT_FALSE(QueryVar(*station_lr.b()->signal_.route_set_ab_));

  // Right train comes in.
  SetVar(*right.b()->request_green(), true);
  Run(10);
  EXPECT_TRUE(QueryVar(*right.b()->signal_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*turnout_r.b.any_route_set_));
  EXPECT_TRUE(QueryVar(*turnout_r.b.route_set_PC_));
  EXPECT_TRUE(QueryVar(*station_rl.b()->body_.route_set_ab_));
  right.inverted_detector()->Set(true);
  station_rl.inverted_detector()->Set(false);
  Run(15);
  EXPECT_FALSE(QueryVar(*turnout_r.b.any_route_set_));
  EXPECT_FALSE(QueryVar(*turnout_r.b.route_set_PC_));
  EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));

  // Left->Right train goes out.
  SetVar(*station_lr.b()->request_green(), true);
  Run(15);
  EXPECT_TRUE(QueryVar(*station_lr.b()->signal_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*right.b()->body_.route_set_ba_));
  // another green is needed beyond the right.
  SetVar(*right.b()->rrequest_green(), true);
  Run(15);
  EXPECT_TRUE(QueryVar(*right.b()->rsignal_.route_set_ab_));
  EXPECT_TRUE(QueryVar(*mid_right.b.route_set_ba_));

  right.inverted_detector()->Set(false);
  Run(15);
  EXPECT_TRUE(QueryVar(*turnout_r.b.any_route_set_));

  right.inverted_detector()->Set(true);
  Run(15);
  EXPECT_FALSE(QueryVar(*turnout_r.b.any_route_set_));
  EXPECT_TRUE(QueryVar(*mid_right.b.route_set_ba_));
  EXPECT_TRUE(QueryVar(*right.b()->body_.route_set_ba_));
  end_right.detector.Set(true);
  Run(15);
  EXPECT_TRUE(QueryVar(*mid_right.b.route_set_ba_));
  EXPECT_TRUE(QueryVar(*right.b()->body_.route_set_ba_));
  right.inverted_detector()->Set(false);
  Run(15);
  EXPECT_TRUE(QueryVar(*mid_right.b.route_set_ba_));
  EXPECT_TRUE(QueryVar(*right.b()->body_.route_set_ba_));
  end_right.detector.Set(false);
  Run(15);
  EXPECT_FALSE(QueryVar(*mid_right.b.route_set_ba_));
  EXPECT_FALSE(QueryVar(*right.b()->body_.route_set_ba_));
}

//                  b         a
//     b   a    ----<<station_1-----     b    a
// ----<left---/----<<station_2-----\----<right---
TEST_F(LogicTest, MovableTurnout) {
  static TestDetectorBlock end_left(this, "end_left");
  static TestDetectorBlock end_right(this, "end_right");
  TestShortTrack mid_right(this, "mid_right");
  TestBlock left(this, "left");
  TestBlock right(this, "right");
  TestBlock station_1(this, "station_1");
  TestBlock station_2(this, "station_2");
  TestMovableTurnout turnout_r(this, "turnout_r");
  TestFixedTurnout turnout_l(this, FixedTurnout::TURNOUT_CLOSED, "turnout_l");

  BindSequence({left.b(), &end_left.b});
  BindSequence({&end_right.b, &mid_right.b, right.b()});
  station_1.b()->side_b()->Bind(turnout_l.b.side_thrown());
  station_1.b()->side_a()->Bind(turnout_r.b.side_thrown());
  station_2.b()->side_b()->Bind(turnout_l.b.side_closed());
  station_2.b()->side_a()->Bind(turnout_r.b.side_closed());

  left.b()->side_a()->Bind(turnout_l.b.side_points());
  right.b()->side_b()->Bind(turnout_r.b.side_points());

  SetupRunner(&brd);
  // No trains anywhere.
  end_right.detector.Set(false);
  end_left.detector.Set(false);
  left.inverted_detector()->Set(true);
  right.inverted_detector()->Set(true);
  station_1.inverted_detector()->Set(true);
  station_2.inverted_detector()->Set(true);
  // Turnout closed.
  SetVar(*turnout_r.magnet.command, false);
  SetVar(*turnout_r.magnet.current_state, false);
  Run(1);
  left.inverted_detector()->Set(true);
  right.inverted_detector()->Set(true);
  station_1.inverted_detector()->Set(true);
  station_2.inverted_detector()->Set(true);
  Run(15);

  // Test turnout detector proxy.
  EXPECT_FALSE(QueryVar(*turnout_r.b.side_points()->LookupNextDetector()));
  EXPECT_FALSE(QueryVar(*turnout_r.b.side_points()->LookupFarDetector()));
  station_2.inverted_detector()->Set(false);
  Run(15);
  EXPECT_TRUE(QueryVar(*turnout_r.b.side_points()->LookupNextDetector()));
  EXPECT_TRUE(QueryVar(*turnout_r.b.side_points()->LookupFarDetector()));
  station_2.inverted_detector()->Set(true);
  Run(15);
  EXPECT_FALSE(QueryVar(*turnout_r.b.side_points()->LookupNextDetector()));
  EXPECT_FALSE(QueryVar(*turnout_r.b.side_points()->LookupFarDetector()));

  for (int i = 0; i < 2; i++) {
    // Source a train from the right.
    end_right.detector.Set(true);
    SetVar(*end_right.b.side_b()->out_try_set_route, true);
    Run(12);
    EXPECT_FALSE(QueryVar(*end_right.b.side_b()->out_try_set_route));
    EXPECT_TRUE(
        QueryVar(*end_right.b.side_b()->binding()->in_route_set_success));
    EXPECT_TRUE(QueryVar(*mid_right.b.route_set_ab_));
    EXPECT_TRUE(QueryVar(*right.b()->body_det_.route_set_ab_));

    // Train reaches its stops on open track outside of the station.
    end_right.detector.Set(false);
    right.inverted_detector()->Set(false);
    Run(12);

    EXPECT_FALSE(QueryVar(*mid_right.b.route_set_ab_));
    EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));

    LOG(INFO, "Giving green to first train");
    SetVar(*right.b()->request_green(), true);
    Run(6);
    EXPECT_FALSE(QueryVar(*right.b()->request_green()));
    EXPECT_TRUE(QueryVar(*right.b()->signal_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*turnout_r.b.any_route_set_));
    EXPECT_TRUE(QueryVar(*turnout_r.b.route_set_PC_));
    EXPECT_TRUE(QueryVar(*station_2.b()->body_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*station_2.b()->body_det_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*station_2.b()->signal_.route_set_ab_));
    right.inverted_detector()->Set(true);
    station_2.inverted_detector()->Set(false);
    Run(15);
    EXPECT_FALSE(QueryVar(*turnout_r.b.any_route_set_));
    EXPECT_FALSE(QueryVar(*turnout_r.b.route_set_PC_));
    EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*station_2.b()->body_det_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*station_2.b()->signal_.route_set_ab_));

    // Source another train.
    end_right.detector.Set(true);
    SetVar(*end_right.b.side_b()->out_try_set_route, true);
    Run(12);
    EXPECT_FALSE(QueryVar(*end_right.b.side_b()->out_try_set_route));
    EXPECT_TRUE(
        QueryVar(*end_right.b.side_b()->binding()->in_route_set_success));
    EXPECT_TRUE(QueryVar(*mid_right.b.route_set_ab_));
    EXPECT_TRUE(QueryVar(*right.b()->body_det_.route_set_ab_));

    // Train 2 reaches its stop on open track outside of the station.
    end_right.detector.Set(false);
    right.inverted_detector()->Set(false);
    Run(12);

    EXPECT_FALSE(QueryVar(*mid_right.b.route_set_ab_));
    EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));

    EXPECT_TRUE(QueryVar(*station_2.b()->body_det_.route_set_ab_));

    LOG(INFO, "Trying green to second train");
    SetVar(*right.b()->request_green(), true);
    Run(5);
    EXPECT_FALSE(QueryVar(*right.b()->side_b()->out_try_set_route));
    EXPECT_FALSE(
        QueryVar(*right.b()->side_b()->binding()->in_route_set_success));
    EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));

    // Switch the turnout.
    SetVar(*turnout_r.magnet.command, true);
    Run(5);
    EXPECT_TRUE(turnout_r.set_1.Get());
    Run(5);
    EXPECT_FALSE(turnout_r.set_1.Get());

    // Give green again, this time it works.
    SetVar(*right.b()->request_green(), true);
    Run(6);
    EXPECT_FALSE(QueryVar(*right.b()->request_green()));
    EXPECT_TRUE(QueryVar(*right.b()->signal_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*turnout_r.b.any_route_set_));
    EXPECT_TRUE(QueryVar(*turnout_r.b.route_set_PT_));
    EXPECT_TRUE(QueryVar(*station_1.b()->body_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*station_1.b()->body_det_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*station_1.b()->signal_.route_set_ab_));
    right.inverted_detector()->Set(true);
    station_1.inverted_detector()->Set(false);
    Run(15);
    EXPECT_FALSE(QueryVar(*turnout_r.b.any_route_set_));
    EXPECT_FALSE(QueryVar(*turnout_r.b.route_set_PT_));
    EXPECT_FALSE(QueryVar(*right.b()->signal_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*station_1.b()->body_det_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*station_1.b()->signal_.route_set_ab_));

    // Get train 1 out.
    SetVar(*station_1.b()->request_green(), true);
    Run(6);
    EXPECT_TRUE(QueryVar(*station_1.b()->signal_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*left.b()->body_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*turnout_l.b.any_route_set_));
    left.inverted_detector()->Set(false);
    station_1.inverted_detector()->Set(true);
    Run(15);
    EXPECT_FALSE(QueryVar(*turnout_l.b.any_route_set_));

    SetVar(*station_2.b()->request_green(), true);
    Run(6);
    EXPECT_TRUE(QueryVar(*left.b()->body_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*station_2.b()->signal_.route_set_ab_));

    // And we will make the train disappear from the left block.
    SetVar(*left.b()->signal_.route_set_ab_, true);  // need outgoing signal
    left.inverted_detector()->Set(true);
    Run(15);
    EXPECT_FALSE(QueryVar(*left.b()->body_.route_set_ab_));

    // So that train 2 can leave too
    SetVar(*station_2.b()->request_green(), true);
    Run(6);
    EXPECT_TRUE(QueryVar(*left.b()->body_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*station_2.b()->signal_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*turnout_l.b.any_route_set_));
    left.inverted_detector()->Set(false);
    station_2.inverted_detector()->Set(true);
    Run(15);

    EXPECT_TRUE(QueryVar(*left.b()->body_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*station_2.b()->signal_.route_set_ab_));

    // Reset the turnout and make seocnd train disappear.
    left.inverted_detector()->Set(true);
    SetVar(*left.b()->signal_.route_set_ab_, true);  // need outgoing signal
    SetVar(*turnout_r.magnet.command, false);
    Run(15);
  }  // rinse repeat.
}

// The DKW test layout is an 8-shaped layout, with signals leading into each
// end of the DKW, and being put back-to-back in pairs. The A1 and A2 are
// connected through one side of the 8, and B1 and B2 are connected through the
// other.

TEST_F(LogicTest, FixedDKW) {
  FixedDKW dkw(DKW::DKW_STRAIGHT, alloc()->Allocate("dkw", 120));
  DKWTestLayout l(this, &dkw);
  //debug_variables = 1;
  SetupRunner(&brd);
  Run(30);
  for (int i = 0; i < 10; i++) {
    fprintf(stderr, "round %d\n", i);
    l.in_a1.inverted_detector()->Set(false);
    Run(20);
    SetVar(*l.in_a1.b()->request_green(), true);
    Run(20);
    EXPECT_TRUE(QueryVar(l.in_a1.b()->route_out()));
    EXPECT_TRUE(l.in_a1.signal_green()->Get());
    EXPECT_FALSE(QueryVar(*l.in_a1.b()->request_green()));
    EXPECT_TRUE(QueryVar(*dkw.any_route()));
    EXPECT_TRUE(QueryVar(*dkw.simulated_occupancy_));
    EXPECT_TRUE(QueryVar(
        *dkw.get_route(DKW::POINT_A1, DKW::POINT_B1)->route_set.get()));

    SetVar(*l.in_b1.b()->rrequest_green(), true);
    Run(20);

    EXPECT_TRUE(QueryVar(l.in_b2.b()->route_in()));

    l.in_b1.inverted_detector()->Set(false);
    Run(20);
    l.in_a1.inverted_detector()->Set(true);
    Run(20);
    l.in_b1.inverted_detector()->Set(true);
    Run(20);
    EXPECT_FALSE(QueryVar(*dkw.any_route()));
    EXPECT_FALSE(QueryVar(*dkw.simulated_occupancy_));
    EXPECT_FALSE(QueryVar(
        *dkw.get_route(DKW::POINT_A1, DKW::POINT_B1)->route_set.get()));

    l.in_b2.inverted_detector()->Set(false);
    Run(20);
    SetVar(*l.in_b2.b()->request_green(), true);
    Run(20);
    EXPECT_TRUE(l.in_b2.signal_green()->Get());
    EXPECT_TRUE(QueryVar(*dkw.any_route()));
    EXPECT_TRUE(QueryVar(
        *dkw.get_route(DKW::POINT_B2, DKW::POINT_A2)->route_set.get()));

    SetVar(*l.in_a2.b()->rrequest_green(), true);
    Run(20);

    EXPECT_TRUE(QueryVar(l.in_a1.b()->route_in()));

    l.in_a2.inverted_detector()->Set(false);
    Run(20);
    l.in_b2.inverted_detector()->Set(true);
    Run(20);
    l.in_a2.inverted_detector()->Set(true);
    Run(20);
    EXPECT_FALSE(QueryVar(*dkw.any_route()));
    EXPECT_FALSE(QueryVar(*dkw.simulated_occupancy_));
    EXPECT_FALSE(QueryVar(
        *dkw.get_route(DKW::POINT_B2, DKW::POINT_A2)->route_set.get()));
  }
}

TEST_F(LogicTest, MovableDKW) {
  FakeBit set_0(this);
  FakeBit set_1(this);
  MagnetDef magnet(&magnet_aut_, "dkw.mgn", &set_0, &set_1, false);
  MovableDKW dkw(alloc()->Allocate("dkw", 120), &magnet);
  DKWTestLayout l(this, &dkw);

  SetupRunner(&brd);
  Run(30);

  auto move = [this, &l, &dkw](TestBlock* from, TestBlock* via, TestBlock* to) {
    EXPECT_TRUE(QueryVar(from->b()->detector()));
    SetVar(*from->b()->request_green(), true);
    Run(20);
    EXPECT_TRUE(QueryVar(from->b()->route_out()));
    EXPECT_TRUE(from->signal_green()->Get());
    EXPECT_TRUE(QueryVar(*dkw.any_route()));
    EXPECT_TRUE(QueryVar(*dkw.simulated_occupancy_));

    EXPECT_TRUE(QueryVar(*dkw.get_route(l.BlockToPoint(from),
                                        l.BlockToPoint(via))->route_set.get()));

    SetVar(*via->b()->rrequest_green(), true);
    Run(20);

    EXPECT_TRUE(QueryVar(to->b()->route_in()));

    via->inverted_detector()->Set(false);
    Run(20);
    from->inverted_detector()->Set(true);
    Run(20);
    via->inverted_detector()->Set(true);
    Run(20);
    EXPECT_FALSE(QueryVar(*dkw.any_route()));
    EXPECT_FALSE(QueryVar(*dkw.simulated_occupancy_));
    EXPECT_FALSE(
        QueryVar(*dkw.get_route(l.BlockToPoint(from), l.BlockToPoint(via))
                      ->route_set.get()));
    to->inverted_detector()->Set(false);
    Run(20);
  };

  SetVar(*magnet.command, MovableDKW::kDKWStateCross);
  SetVar(*magnet.current_state, MovableDKW::kDKWStateCross);
  l.in_a1.inverted_detector()->Set(false);
  Run(30);

  for (int i = 0; i < 3; ++i) {
    // A1->B1; B2->A2
    fprintf(stderr, "round %d step 1\n", i);
    move(&l.in_a1, &l.in_b1, &l.in_b2);
    fprintf(stderr, "round %d step 2\n", i);
    move(&l.in_b2, &l.in_a2, &l.in_a1);
    fprintf(stderr, "round %d step 1b\n", i);
    move(&l.in_a1, &l.in_b1, &l.in_b2);
    fprintf(stderr, "round %d step 2b\n", i);
    move(&l.in_b2, &l.in_a2, &l.in_a1);
    SetVar(*magnet.command, MovableDKW::kDKWStateCurved);
    Run(20);
    // A1->B2; B1->A2
    fprintf(stderr, "round %d step 3\n", i);
    move(&l.in_a1, &l.in_b2, &l.in_b1);
    fprintf(stderr, "round %d step 4\n", i);
    move(&l.in_b1, &l.in_a2, &l.in_a1);
    fprintf(stderr, "round %d step 3b\n", i);
    move(&l.in_a1, &l.in_b2, &l.in_b1);
    fprintf(stderr, "round %d step 4b\n", i);
    move(&l.in_b1, &l.in_a2, &l.in_a1);

    fprintf(stderr, "round %d step 5\n", i);
    move(&l.in_a1, &l.in_b2, &l.in_b1);
    SetVar(*magnet.command, MovableDKW::kDKWStateCross);
    Run(20);
    // A2->B2; B1->A1;
    fprintf(stderr, "round %d step 6\n", i);
    move(&l.in_b1, &l.in_a1, &l.in_a2);
    fprintf(stderr, "round %d step 7\n", i);
    move(&l.in_a2, &l.in_b2, &l.in_b1);
    fprintf(stderr, "round %d step 6b\n", i);
    move(&l.in_b1, &l.in_a1, &l.in_a2);
    fprintf(stderr, "round %d step 7b\n", i);
    move(&l.in_a2, &l.in_b2, &l.in_b1);

    fprintf(stderr, "round %d step 8\n", i);
    move(&l.in_b1, &l.in_a1, &l.in_a2);
    SetVar(*magnet.command, MovableDKW::kDKWStateCurved);
    Run(20);
    // A2->B1; B2->A1
    fprintf(stderr, "round %d step 9\n", i);
    move(&l.in_a2, &l.in_b1, &l.in_b2);
    fprintf(stderr, "round %d step a\n", i);
    move(&l.in_b2, &l.in_a1, &l.in_a2);
    fprintf(stderr, "round %d step 9b\n", i);
    move(&l.in_a2, &l.in_b1, &l.in_b2);
    fprintf(stderr, "round %d step ab\n", i);
    move(&l.in_b2, &l.in_a1, &l.in_a2);
    // Let's get back to a1 for another round.
    fprintf(stderr, "round %d step b\n", i);
    move(&l.in_a2, &l.in_b1, &l.in_b2);
    SetVar(*magnet.command, MovableDKW::kDKWStateCross);
    Run(20);
    fprintf(stderr, "round %d step c\n", i);
    move(&l.in_b2, &l.in_a2, &l.in_a1);
  }
}

TEST_F(LogicTest, DISABLED_100trainz) {
  TestDetectorBlock before(this, "before");
  static StraightTrackLong mid(alloc()->Allocate("mid", 80));
  DefAut(autmid, brd, { mid.RunAll(this); });
  TestBlock first(this, "first");
  TestBlock second(this, "second");
  static StraightTrackLong after(alloc()->Allocate("after", 80));

  BindSequence({&before.b, first.b(), &mid, second.b(), &after});


  // This will immediately accept a route at the end stop.
  DefAut(strategyaut, brd, {
    LocalVariable* try_set_route =
        ImportVariable(after.side_a()->binding()->out_try_set_route.get());
    LocalVariable* route_set_succcess =
        ImportVariable(after.side_a()->in_route_set_success.get());
    Def().IfReg1(*try_set_route).ActReg0(try_set_route).ActReg1(
        route_set_succcess);
  });

  SetupRunner(&brd);
  before.detector.Set(true);
  // The initial state is a train at both blocks.
  first.inverted_detector()->Set(false);
  second.inverted_detector()->Set(false);
  Run(1);
  first.inverted_detector()->Set(false);
  second.inverted_detector()->Set(false);
  Run(20);
  EXPECT_TRUE(QueryVar(*first.b()->body_det_.simulated_occupancy_));
  EXPECT_TRUE(QueryVar(*second.b()->body_det_.simulated_occupancy_));

  for (int i = 0; i < 100; ++i) {
    Run(10);
    EXPECT_FALSE(first.signal_green()->Get());
    EXPECT_FALSE(second.signal_green()->Get());

    // The rear train cannot move forward.
    SetVar(*first.b()->request_green(), true);
    Run(10);
    EXPECT_FALSE(QueryVar(*first.b()->request_green()));
    EXPECT_FALSE(first.signal_green()->Get());
    EXPECT_FALSE(QueryVar(*mid.route_set_ab_));

    // Makes the second train leave.
    SetVar(*second.b()->request_green(), true);
    Run(10);
    EXPECT_FALSE(QueryVar(*second.b()->request_green()));
    EXPECT_TRUE(second.signal_green()->Get());

    // The rear train still cannot move forward.
    SetVar(*first.b()->request_green(), true);
    Run(10);
    EXPECT_FALSE(QueryVar(*first.b()->request_green()));
    EXPECT_FALSE(first.signal_green()->Get());
    EXPECT_FALSE(QueryVar(*mid.route_set_ab_));

    // Makes the front train leave.
    second.inverted_detector()->Set(true);
    Run(14);
    EXPECT_FALSE(QueryVar(*second.b()->request_green()));
    EXPECT_FALSE(second.signal_green()->Get());
    EXPECT_FALSE(QueryVar(*second.b()->signal_.route_set_ab_));

    // Now we can run the rear train.
    SetVar(*first.b()->request_green(), true);
    Run(10);
    EXPECT_FALSE(QueryVar(*first.b()->request_green()));
    EXPECT_TRUE(QueryVar(*first.b()->signal_.route_set_ab_));
    EXPECT_TRUE(first.signal_green()->Get());
    EXPECT_TRUE(QueryVar(*mid.route_set_ab_));
    EXPECT_TRUE(QueryVar(*second.b()->body_det_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*second.b()->signal_.route_set_ab_));

    // But the third train cannot get in yet,
    SetVar(*first.b()->body_.side_b()->out_try_set_route, true);
    Run(5);
    EXPECT_FALSE(QueryVar(*first.b()->body_.side_b()->out_try_set_route));
    EXPECT_TRUE(QueryVar(*first.b()->body_.side_b()->binding()->in_route_set_failure));
    if (i != 0) {
      EXPECT_TRUE(
          QueryVar(*first.b()->body_det_.route_set_ab_));  // because the route is still there.
    }

    // Rear train leaves its block.
    first.inverted_detector()->Set(true);
    Run(15);
    EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));  // route gone.
    EXPECT_FALSE(QueryVar(*first.b()->body_det_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*first.b()->body_.route_set_ab_));

    // The third train can now come.
    SetVar(*first.b()->body_.side_b()->out_try_set_route, true);
    Run(5);
    EXPECT_FALSE(QueryVar(*first.b()->body_.side_b()->out_try_set_route));
    EXPECT_FALSE(
        QueryVar(*first.b()->body_.side_b()->binding()->in_route_set_failure));
    EXPECT_TRUE(QueryVar(*first.b()->body_.side_b()->binding()->in_route_set_success));
    EXPECT_FALSE(QueryVar(*first.b()->signal_.route_set_ab_));
    EXPECT_TRUE(QueryVar(*first.b()->body_det_.route_set_ab_));

    // Second train reaches rear block.
    second.inverted_detector()->Set(false);
    Run(15);
    EXPECT_FALSE(QueryVar(*mid.route_set_ab_));
    EXPECT_TRUE(QueryVar(*second.b()->body_det_.route_set_ab_));
    EXPECT_FALSE(QueryVar(*second.b()->signal_.route_set_ab_));

    // Third train reaches second block.
    first.inverted_detector()->Set(false);
    Run(15);
  }
}

TEST_F(LogicTest, Magnets) {
  FakeBit v0s0(this);
  FakeBit v0s1(this);
  FakeBit v1s0(this);
  FakeBit v1s1(this);

  MagnetCommandAutomata aut(&brd, alloc());
  MagnetDef def0(&aut, "v0", &v0s0, &v0s1, false);
  MagnetDef def1(&aut, "v1", &v1s0, &v1s1, false);

  v0s0.Set(true);
  v1s1.Set(true);

  SetVar(*def0.command, false);
  SetVar(*def1.command, false);

  SetupRunner(&brd);
  Run(40); // should be enough time for reset behavior.
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());

  Run(5);  // adds one tick
  // No command
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());
  
  SetVar(*def1.command, true);
  Run(2);
  // Tick is not done yet.
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());

  Run(3);
  // Tick is here, command taken
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_TRUE(v1s1.Get());

  Run(2);
  // Next tick not here yet
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_TRUE(v1s1.Get());

  Run(3);
  // Next tick: turns off signal
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());

  // Now we command both together.
  SetVar(*def0.command, true);
  SetVar(*def1.command, false);

  Run();
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());

  Run(3);
  // First signal comes.
  EXPECT_FALSE(v0s0.Get());
  EXPECT_TRUE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());

  Run(3);
  // second signal comes.
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_TRUE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());

  Run(3);
  // All done.
  EXPECT_FALSE(v0s0.Get());
  EXPECT_FALSE(v0s1.Get());
  EXPECT_FALSE(v1s0.Get());
  EXPECT_FALSE(v1s1.Get());
}

TEST_F(LogicTest, FlipFlopSimple) {
  FlipFlopAutomata flaut(&brd, "flipflop", alloc());
  FlipFlopClient cla("a", &flaut);
  FlipFlopClient clb("b", &flaut);

  SetupRunner(&brd);
  Run(10);
  for (int i = 0; i < 13; ++i) {
    FlipFlopClient* t = &cla;
    FlipFlopClient* o = &clb;
    if (i&1) {
      std::swap(t, o);
    }
    LOG(INFO, "num %d t %p o %p", i, t, o);
    SetVar(*t->request(), true);
    SetVar(*o->request(), true);
    Run(10);
    EXPECT_TRUE(QueryVar(*t->granted()));
    EXPECT_FALSE(QueryVar(*o->granted()));
    SetVar(*t->request(), false);
    SetVar(*t->granted(), false);
    SetVar(*t->taken(), true);
    SetVar(*o->request(), false);
    Run(10);
  }
}

TEST_F(LogicTest, FlipFlopTriple) {
  FlipFlopAutomata flaut(&brd, "flipflop", alloc());
  FlipFlopClient cla("a", &flaut);
  FlipFlopClient clb("b", &flaut);
  FlipFlopClient clc("c", &flaut);

  SetupRunner(&brd);
  Run(10);
  FlipFlopClient *t = &cla, *o1 = &clb, *o2 = &clc;
  for (int i = 0; i < 13; ++i) {
    LOG(INFO, "num %d", i);
    SetVar(*t->request(), true);
    SetVar(*o1->request(), true);
    SetVar(*o2->request(), true);
    Run(10);
    EXPECT_TRUE(QueryVar(*t->granted()));
    EXPECT_FALSE(QueryVar(*o1->granted()));
    EXPECT_FALSE(QueryVar(*o2->granted()));
    SetVar(*t->request(), false);
    SetVar(*t->granted(), false);
    SetVar(*t->taken(), true);
    SetVar(*o1->request(), false);
    SetVar(*o2->request(), false);
    Run(10);
    std::swap(t, o1);
    std::swap(o1, o2);
  }
}

TEST_F(LogicTest, FlipFlopRedacted) {
  FlipFlopAutomata flaut(&brd, "flipflop", alloc());
  FlipFlopClient cla("a", &flaut);
  FlipFlopClient clb("b", &flaut);

  SetupRunner(&brd);
  Run(10);
  for (int i = 0; i < 13; ++i) {
    FlipFlopClient* t = &cla;
    FlipFlopClient* o = &clb;
    if (i&1) {
      std::swap(t, o);
    }

    LOG(INFO, "num %d t %p o %p", i, t, o);
    SetVar(*t->request(), true);
    SetVar(*o->request(), true);
    Run(10);
    EXPECT_TRUE(QueryVar(*t->granted()));
    EXPECT_FALSE(QueryVar(*o->granted()));
    SetVar(*t->request(), false);
    Run(40);
    EXPECT_FALSE(QueryVar(*t->granted()));
    EXPECT_TRUE(QueryVar(*o->granted()));
    SetVar(*o->granted(), false);
    SetVar(*o->taken(), true);
    SetVar(*t->request(), false);
    Run(10);
    // Now we also take t.
    SetVar(*t->request(), true);
    SetVar(*o->request(), true);
    Run(10);
    EXPECT_TRUE(QueryVar(*t->granted()));
    EXPECT_FALSE(QueryVar(*o->granted()));
    SetVar(*t->request(), false);
    SetVar(*t->granted(), false);
    SetVar(*t->taken(), true);
    SetVar(*o->request(), false);
    Run(10);
  }
}

TEST_F(LogicTest, FlipFlopSteal) {
  FlipFlopAutomata flaut(&brd, "flipflop", alloc());
  FlipFlopClient cla("a", &flaut);
  FlipFlopClient clb("b", &flaut);

  SetupRunner(&brd);
  Run(10);
  for (int i = 0; i < 13; ++i) {
    FlipFlopClient* t = &cla;
    FlipFlopClient* o = &clb;
    // We purposefully take the same client twice in a row so that we will
    // surely be stealing once in a while.
    if (i&2) {
      std::swap(t, o);
    }
    LOG(INFO, "num %d t %p o %p", i, t, o);
    SetVar(*t->request(), true);
    Run(10);
    EXPECT_TRUE(QueryVar(*t->granted()));
    EXPECT_FALSE(QueryVar(*o->granted()));
    SetVar(*t->request(), false);
    SetVar(*t->granted(), false);
    SetVar(*t->taken(), true);
    SetVar(*o->request(), false);
    Run(10);
  }
}

TEST_F(LogicTrainTest, ScheduleStraight) {
  TestDetectorBlock before(this, "before");
  static StraightTrackLong mid(alloc()->Allocate("mid", 80));
  DefAut(autmid, brd, { mid.RunAll(this); });
  static TestBlock first(this, "first");
  static TestBlock second(this, "second");
  static StraightTrackLong after(alloc()->Allocate("after", 80));

  BindSequence({&before.b, first.b(), &mid, second.b(), &after});

  ASSERT_EQ(first.b()->signal_.side_b(), mid.side_a()->binding());

  static FakeBit mcont(this);

  class MyTrain : public TrainSchedule {
   public:
    MyTrain(Board* b, const AllocatorPtr& alloc)
        : TrainSchedule("mytrain", b,
                        openlcb::TractionDefs::NODE_ID_DCC | 0x1384,
                        alloc->Allocate("mytrain.pbits", 8),
                        alloc->Allocate("mytrain", 16)) {}

    void RunTransition(Automata* aut) OVERRIDE {
      auto* cv = aut->ImportVariable(&mcont);
      Def()
          .IfState(StWaiting)
          .IfReg1(*cv)
          .ActState(StReadyToGo)
          .ActReg0(cv);
      Def()
          .ActImportVariable(*first.b()->request_green(),
                             routing_block_request_green_)
          .ActImportVariable(first.b()->route_out(),
                             routing_block_route_out_)
          .ActImportVariable(second.b()->detector(),
                             next_block_detector_);
      MapCurrentBlockPermaloc(*first.b());
      Def()
          .ActImportVariable(second.b()->detector(), current_block_detector_)
          .ActImportVariable(
              *AllocateOrGetLocationByBlock(*second.b())->permaloc(),
               next_block_permaloc_);

      Def().IfState(StRequestTransition).ActState(StTransitionDone);
    }

   private:
    FRIEND_TEST(automata::LogicTrainTest, ScheduleStraight);
  } train_aut(&brd, block_.allocator());

  SetupRunner(&brd);
  
  // No trains initially.
  first.inverted_detector()->Set(true);
  second.inverted_detector()->Set(true);
  Run(1);

  // No trains initially.
  first.inverted_detector()->Set(true);
  second.inverted_detector()->Set(true);
  Run(20);
  EXPECT_FALSE(QueryVar(*first.b()->body_det_.simulated_occupancy_));
  EXPECT_FALSE(QueryVar(*second.b()->body_det_.simulated_occupancy_));

  // Train is at first. No green yet.
  mcont.Set(false);
  first.inverted_detector()->Set(false);
  second.inverted_detector()->Set(true);
  Run(30);
  LOG(INFO, "Sending off train.");
  EXPECT_EQ(0, trainImpl_.get_speed().speed());
  mcont.Set(true);
  Run(30);
  EXPECT_TRUE(QueryVar(*train_aut.is_moving_));
  //EXPECT_EQ(StMoving.state, runner_->GetAllAutomatas().back()->GetState());
  EXPECT_TRUE(first.signal_green()->Get());
  EXPECT_FALSE(mcont.Get());
  wait();
  EXPECT_EQ(40, (int)(trainImpl_.get_speed().mph() + 0.5));

  LOG(INFO, "Train arriving at destination.");
  first.inverted_detector()->Set(true);
  second.inverted_detector()->Set(false);
  Run(20);

  wait();
  EXPECT_EQ(0, trainImpl_.get_speed().mph());
}

}  // namespace automata
