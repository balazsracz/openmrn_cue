#include "logic/VM.hxx"

#include "utils/test_main.hxx"

#include "logic/Driver.hxx"
#include "logic/Bytecode.hxx"

using ::testing::ElementsAre;
using ::testing::Eq;
using ::testing::StrEq;
using ::testing::StartsWith;

TempDir g_dir;

namespace logic {

class VMTest : public ::testing::Test {
 protected:
  VMTest() {
    vm_.set_output([this](string d) { output_.emplace_back(std::move(d)); });
  }

  ::testing::AssertionResult compile(const string& sourcecode) {
    TempFile tf(g_dir, "simple");
    tf.rewrite(sourcecode);
    logic::Driver d;
    if (d.parse_file(tf.name()) != 0) {
      return ::testing::AssertionFailure() << "Failed to compile.";
    }
    d.serialize(&bytecode_);
    return ::testing::AssertionSuccess();
  }

  ::testing::AssertionResult run() {
    if (vm_.execute(bytecode_)) {
      return ::testing::AssertionSuccess();
    } else {
      return ::testing::AssertionFailure() << "VM exception: " << vm_.error_;
    }
  }

  std::vector<int> get_op_stack() {
    return vm_.operand_stack_;
  }

  void clear() {
    bytecode_.clear();
    vm_.operand_stack_.clear();
    vm_.error_.clear();
  }
  
  /// Stuff that the VM has printed to the output.
  std::vector<std::string> output_;
  /// The virtual machine instance.
  VM vm_;
  /// The compiled bytecode.
  std::string bytecode_;
};

TEST_F(VMTest, push_constant) {
  bytecode_ = {PUSH_CONSTANT_0, PUSH_CONSTANT_1, PUSH_CONSTANT};
  BytecodeStream::append_varint(&bytecode_, -3271);
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0, 1, -3271));
}

TEST_F(VMTest, push_constant_exception) {
  bytecode_ = {PUSH_CONSTANT, (char)0x83};
  EXPECT_FALSE(run());
  EXPECT_THAT(vm_.get_error(), StrEq("Unexpected EOF parsing varint"));
}

TEST_F(VMTest, plus) {
  bytecode_ = {PUSH_CONSTANT_1, PUSH_CONSTANT};
  BytecodeStream::append_varint(&bytecode_, 13);
  bytecode_.append({NUMERIC_PLUS});
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(14));
}

TEST_F(VMTest, plus_underflow) {
  bytecode_ = {PUSH_CONSTANT_1, NUMERIC_PLUS};
  EXPECT_FALSE(run());
  EXPECT_THAT(vm_.get_error(), StartsWith("Stack underflow"));
}

TEST_F(VMTest, enter) {
  bytecode_ = {PUSH_CONSTANT_1, PUSH_CONSTANT_0, PUSH_CONSTANT_1, ENTER};
  BytecodeStream::append_varint(&bytecode_, 4);
  EXPECT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1,0,1,0,0,0,0));
}

TEST_F(VMTest, plus_e2e) {
  ASSERT_TRUE(compile("int a; a=1+3+8"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(12));
}

TEST_F(VMTest, multi_command) {
  ASSERT_TRUE(compile("int a; int b; a=1+3+8\nb=5"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(12, 5));
}

TEST_F(VMTest, multi_command_braces) {
  ASSERT_TRUE(compile("int a=1+3+8;\n{int c=1;\nint d=33;}\nint b=5;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(12, 1, 33, 5));
}

TEST_F(VMTest, ifthenelse_1) {
  ASSERT_TRUE(compile("int x=9; int a; int b; if(true) {a=1+3} else {b=2} int y=7;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 4, 0, 7));
}

TEST_F(VMTest, ifthenelse_2) {
  ASSERT_TRUE(compile("int x=9, a, b; if(inactive) {a=1+3} else {b=2} int y=7;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 0, 2, 7));
}

TEST_F(VMTest, ifthenelse_3) {
  ASSERT_TRUE(compile("int x=9,a,b,y; if(False) {a=1+3} else {b=2} y=7"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 0, 2, 7));
}

TEST_F(VMTest, ifthen) {
  ASSERT_TRUE(compile("int x=9,a,bb,y; if(Thrown) {a=1+3 bb=55} y=7"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 4, 55, 7));
}

TEST_F(VMTest, ifthen_false) {
  ASSERT_TRUE(compile("int x=9,a,y; if(CLOSED) {a=1+3} y=7"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 0, 7));
}

TEST_F(VMTest, bool_and) {
  ASSERT_TRUE(compile("int a=1; if(true && true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true && false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false && false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false && true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true and true and true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true && true && false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false && true && true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));
}

TEST_F(VMTest, bool_or) {
  ASSERT_TRUE(compile("int a=1; if(true || true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true || false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false or false or false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || true || false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || false || true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));
}

TEST_F(VMTest, bool_variable) {
  ASSERT_TRUE(compile("bool a=false,b=true,c=true,d,e=true;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,1,1,0,1));

  clear();
  
  ASSERT_TRUE(compile("bool a=false,b=true,c=true; if(true) {b = false}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,0,1));
}

TEST_F(VMTest, int_variable) {
  ASSERT_TRUE(compile("int a=0,b=4,c=2,d,e=-4;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,4,2,0,-4));

  clear();

  ASSERT_TRUE(compile("int a=0,b=4,c=0-2,d,e=-4;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,4,-2,0,-4));
}

TEST_F(VMTest, minus) {
  ASSERT_TRUE(compile("int a=-1,b=4-2,c=1+-3,d=5--1,e=4-4;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(-1,2,-2,6,0));
}

TEST_F(VMTest, int_precedence) {
  ASSERT_TRUE(compile("int a=5+3*2-4/2;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(5+6-2));
}

TEST_F(VMTest, int_ops) {
  ASSERT_TRUE(compile("int a=3*2,b=5-1,c=6+2,d=5/2,e=8%3;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(6, 4, 8, 2, 2));
}


} // namespace logic
