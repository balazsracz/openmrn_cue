/** \copyright
 * Copyright (c) 2019, Balazs Racz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are  permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \file VM.cxxtest
 *
 * Integration tests for the logic language and unit tests for the virtual
 * machine.
 *
 * @author Balazs Racz
 * @date 15 June 2019
 */

#include "logic/VM.hxx"

#include "utils/test_main.hxx"

#include "logic/Driver.hxx"
#include "logic/Bytecode.hxx"
#include "logic/MockVariable.hxx"

using ::testing::ElementsAre;
using ::testing::Eq;
using ::testing::StrEq;
using ::testing::StartsWith;
using ::testing::StrictMock;
using ::testing::Return;
using ::testing::_;

TempDir g_dir;

namespace logic {

class VMTest : public ::testing::Test {
 protected:
  VMTest() {
    vm_.set_output([this](string d) { output_.emplace_back(std::move(d)); });
  }

  ::testing::AssertionResult compile(const string& sourcecode) {
    TempFile tf(g_dir, "simple");
    tf.rewrite(sourcecode);
    logic::Driver d;
    if (d.parse_file(tf.name()) != 0) {
      return ::testing::AssertionFailure() << "Failed to compile.";
    }
    d.serialize(&bytecode_);
    return ::testing::AssertionSuccess();
  }

  ::testing::AssertionResult run() {
    if (vm_.execute(bytecode_)) {
      return ::testing::AssertionSuccess();
    } else {
      return ::testing::AssertionFailure() << "VM exception: " << vm_.error_;
    }
  }

  ::testing::AssertionResult run_preamble() {
    vm_.set_preamble(true);
    if (vm_.execute(bytecode_)) {
      vm_.set_preamble(false);
      return ::testing::AssertionSuccess();
    } else {
      vm_.set_preamble(false);
      return ::testing::AssertionFailure() << "VM exception: " << vm_.error_;
    }
  }
  
  std::vector<int> get_op_stack() {
    return vm_.operand_stack_;
  }

  const VM::ExternalVariableMap& get_external_vars() {
    return vm_.external_variables_;
  }

  const std::vector<VM::VariableReference>& get_var_stack() {
    return vm_.variable_stack_;
  }

  /// Directly inserts a variable into the VM's variable stack.
  /// @param arg will be used by the system to do fetches and stores in the
  /// variable.
  /// @return the mock. Ownership is not transferred.
  StrictMock<MockVariable>* inject_variable(unsigned arg = 0) {
    StrictMock<MockVariable>* r = new StrictMock<MockVariable>();
    vm_.variable_stack_.emplace_back();
    vm_.variable_stack_.back().var = r;
    vm_.variable_stack_.back().owned_var.reset(r);
    vm_.variable_stack_.back().arg = arg;
    return r;
  }

  void clear() {
    bytecode_.clear();
    vm_.operand_stack_.clear();
    vm_.error_.clear();
  }

  /// Stuff that the VM has printed to the output.
  std::vector<std::string> output_;
  StrictMock<MockVariableFactory> mock_factory_;
  /// The virtual machine instance.
  VM vm_{&mock_factory_};
  /// The compiled bytecode.
  std::string bytecode_;
};

TEST_F(VMTest, push_constant) {
  bytecode_ = {PUSH_CONSTANT_0, PUSH_CONSTANT_1, PUSH_CONSTANT};
  BytecodeStream::append_varint(&bytecode_, -3271);
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0, 1, -3271));
}

TEST_F(VMTest, push_constant_exception) {
  bytecode_ = {PUSH_CONSTANT, (char)0x83};
  EXPECT_FALSE(run());
  EXPECT_THAT(vm_.get_error(), StrEq("Unexpected EOF parsing varint"));
}

TEST_F(VMTest, create_variable) {
  BytecodeStream::append_opcode(&bytecode_, LOAD_STRING);
  BytecodeStream::append_string(&bytecode_, "varname");
  BytecodeStream::append_opcode(&bytecode_, CREATE_VAR);
  BytecodeStream::append_varint(&bytecode_, 12345);
  auto* var = mock_factory_.expect_variable("varname", _);
  ASSERT_TRUE(run());
  // Check guid and variable pointer.
  const auto& m = get_external_vars();
  auto it = m.find(12345);
  ASSERT_TRUE(it != m.end());
  EXPECT_EQ(12345u, it->first);
  EXPECT_EQ(var, it->second.get());
}

TEST_F(VMTest, import_variable) {
  BytecodeStream::append_opcode(&bytecode_, LOAD_STRING);
  BytecodeStream::append_string(&bytecode_, "varname");
  BytecodeStream::append_opcode(&bytecode_, CREATE_VAR);
  BytecodeStream::append_varint(&bytecode_, 12345);
  auto* var = mock_factory_.expect_variable("varname", _);
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT);
  BytecodeStream::append_varint(&bytecode_, 12345);
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT_0);
  BytecodeStream::append_opcode(&bytecode_, IMPORT_VAR);
  // Imports a second variable.
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT);
  BytecodeStream::append_varint(&bytecode_, 12345);
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT);
  BytecodeStream::append_varint(&bytecode_, 42);
  BytecodeStream::append_opcode(&bytecode_, IMPORT_VAR);
  ASSERT_TRUE(run());
  auto& varstack = get_var_stack();
  ASSERT_EQ(2u, varstack.size());
  EXPECT_EQ(var, varstack[0].var);
  EXPECT_EQ(0u, varstack[0].arg);
  EXPECT_EQ(var, varstack[1].var);
  EXPECT_EQ(42u, varstack[1].arg);
  EXPECT_THAT(get_op_stack(), ElementsAre(0, 1));
}

TEST_F(VMTest, plus) {
  bytecode_ = {PUSH_CONSTANT_1, PUSH_CONSTANT};
  BytecodeStream::append_varint(&bytecode_, 13);
  bytecode_.append({NUMERIC_PLUS});
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(14));
}

TEST_F(VMTest, plus_underflow) {
  bytecode_ = {PUSH_CONSTANT_1, NUMERIC_PLUS};
  EXPECT_FALSE(run());
  EXPECT_THAT(vm_.get_error(), StartsWith("Stack underflow"));
}

TEST_F(VMTest, enter) {
  bytecode_ = {PUSH_CONSTANT_1, PUSH_CONSTANT_0, PUSH_CONSTANT_1, ENTER};
  BytecodeStream::append_varint(&bytecode_, 4);
  EXPECT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1,0,1,0,0,0,0));
}

TEST_F(VMTest, plus_e2e) {
  ASSERT_TRUE(compile("int a; a=1+3+8"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(12));
}

TEST_F(VMTest, multi_command) {
  ASSERT_TRUE(compile("int a; int b; a=1+3+8\nb=5"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(12, 5));
}

TEST_F(VMTest, multi_command_braces) {
  ASSERT_TRUE(compile("int a=1+3+8;\n{int c=1;\nint d=33;}\nint b=5;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(12, 1, 33, 5));
}

TEST_F(VMTest, ifthenelse_1) {
  ASSERT_TRUE(compile("int x=9; int a; int b; if(true) {a=1+3} else {b=2} int y=7;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 4, 0, 7));
}

TEST_F(VMTest, ifthenelse_2) {
  ASSERT_TRUE(compile("int x=9, a, b; if(inactive) {a=1+3} else {b=2} int y=7;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 0, 2, 7));
}

TEST_F(VMTest, ifthenelse_3) {
  ASSERT_TRUE(compile("int x=9,a,b,y; if(False) {a=1+3} else {b=2} y=7"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 0, 2, 7));
}

TEST_F(VMTest, ifthen) {
  ASSERT_TRUE(compile("int x=9,a,bb,y; if(Thrown) {a=1+3 bb=55} y=7"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 4, 55, 7));
}

TEST_F(VMTest, ifthen_false) {
  ASSERT_TRUE(compile("int x=9,a,y; if(CLOSED) {a=1+3} y=7"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(9, 0, 7));
}

TEST_F(VMTest, bool_and) {
  ASSERT_TRUE(compile("int a=1; if(true && true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true && false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false && false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false && true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true and true and true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true && true && false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false && true && true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));
}

TEST_F(VMTest, bool_or) {
  ASSERT_TRUE(compile("int a=1; if(true || true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(true || false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false or false or false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || true || false) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));

  clear();

  ASSERT_TRUE(compile("int a=1; if(false || false || true) {a=1+3}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(4));
}

TEST_F(VMTest, bool_variable) {
  ASSERT_TRUE(compile("bool a=false,b=true,c=true,d,e=true;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,1,1,0,1));

  clear();

  ASSERT_TRUE(compile("bool a=false,b=true,c=true; if(true) {b = false}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,0,1));

  clear();

  ASSERT_TRUE(compile("bool a=false,b=a,c=true&&b,d; if(c) {a = true} else {d=true}"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,0,0,1));
}

TEST_F(VMTest, int_variable) {
  ASSERT_TRUE(compile("int a=0,b=4,c=2,d,e=-4;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,4,2,0,-4));

  clear();

  ASSERT_TRUE(compile("int a=0,b=4,c=0-2,d,e=-4;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,4,-2,0,-4));

  clear();

  ASSERT_TRUE(compile("int a=0,b=a+3,c=-2,d=b*c;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0,3,-2,-6));
}

TEST_F(VMTest, minus) {
  ASSERT_TRUE(compile("int a=-1,b=4-2,c=1+-3,d=5--1,e=4-4;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(-1,2,-2,6,0));
}

TEST_F(VMTest, int_precedence) {
  ASSERT_TRUE(compile("int a=5+3*2-4/2;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(5+6-2));
}

TEST_F(VMTest, int_ops) {
  ASSERT_TRUE(compile("int a=3*2,b=5-1,c=6+2,d=5/2,e=8%3;"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(6, 4, 8, 2, 2));
}

TEST_F(VMTest, indirect_load) {
  auto* m1 = inject_variable(13);
  auto* m2 = inject_variable(42);
  
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT_0);
  BytecodeStream::append_opcode(&bytecode_, INDIRECT_LOAD);
  EXPECT_CALL(*m1, read(&mock_factory_, 13)).WillOnce(Return(442));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(442));

  bytecode_.clear();
  
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT_1);
  BytecodeStream::append_opcode(&bytecode_, INDIRECT_LOAD);
  EXPECT_CALL(*m2, read(&mock_factory_, 42)).WillOnce(Return(561));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(561));
}

TEST_F(VMTest, indirect_store) {
  auto* m1 = inject_variable(13);
  auto* m2 = inject_variable(42);
  
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT);
  BytecodeStream::append_varint(&bytecode_, 456);
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT_0);
  BytecodeStream::append_opcode(&bytecode_, INDIRECT_STORE);
  EXPECT_CALL(*m1, write(&mock_factory_, 13, 456));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre());

  bytecode_.clear();
  
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT);
  BytecodeStream::append_varint(&bytecode_, 118);
  BytecodeStream::append_opcode(&bytecode_, PUSH_CONSTANT_1);
  BytecodeStream::append_opcode(&bytecode_, INDIRECT_STORE);
  EXPECT_CALL(*m2, write(&mock_factory_, 42, 118));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre());
}

TEST_F(VMTest, indirect_create_e2e) {
  ASSERT_TRUE(compile("exported int a; exported int b; int c=4; c=c+1"));
  auto* vara = mock_factory_.expect_variable(
      "a", ::testing::Field(&VariableCreationRequest::block_num, 0));
  auto* varb = mock_factory_.expect_variable("b", _);
  ASSERT_TRUE(run_preamble());
  EXPECT_THAT(get_op_stack(), ElementsAre());

  // Check guid and variable pointer.
  const auto& m = get_external_vars();
  auto it = m.find(1);
  ASSERT_TRUE(it != m.end());
  EXPECT_EQ(1u, it->first);
  EXPECT_EQ(vara, it->second.get());
  it = m.find(2);
  ASSERT_TRUE(it != m.end());
  EXPECT_EQ(2u, it->first);
  EXPECT_EQ(varb, it->second.get());
  
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0, 1, 5));
}

TEST_F(VMTest, indirect_e2e) {
  ASSERT_TRUE(compile("exported int a; exported int b; int c=b; a=b"));
  auto* vara = mock_factory_.expect_variable(
      "a", ::testing::Field(&VariableCreationRequest::block_num, 11));
  auto* varb = mock_factory_.expect_variable("b", _);
  vm_.set_block_num(11);
  ASSERT_TRUE(run_preamble());

  ::testing::InSequence s;
  EXPECT_CALL(*varb, read(&mock_factory_, 0)).WillOnce(Return(561));
  EXPECT_CALL(*varb, read(&mock_factory_, 0)).WillOnce(Return(112));
  EXPECT_CALL(*vara, write(&mock_factory_, 0, 112));
  
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0, 1, 561));
}

TEST_F(VMTest, indirect_create_e2e_bool) {
  ASSERT_TRUE(compile("exported bool a; exported bool b; bool c=True;"));
  auto* vara = mock_factory_.expect_variable("a", _);
  auto* varb = mock_factory_.expect_variable("b", _);
  ASSERT_TRUE(run_preamble());
  EXPECT_THAT(get_op_stack(), ElementsAre());

  // Check guid and variable pointer.
  const auto& m = get_external_vars();
  auto it = m.find(1);
  ASSERT_TRUE(it != m.end());
  EXPECT_EQ(1u, it->first);
  EXPECT_EQ(vara, it->second.get());
  it = m.find(2);
  ASSERT_TRUE(it != m.end());
  EXPECT_EQ(2u, it->first);
  EXPECT_EQ(varb, it->second.get());
  
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0, 1, 1));
}

TEST_F(VMTest, indirect_e2e_bool) {
  ASSERT_TRUE(compile("exported bool a;\n exported bool b;\n bool c=b&&a;\n a=b"));
  auto* vara = mock_factory_.expect_variable("a", _);
  auto* varb = mock_factory_.expect_variable("b", _);
  ASSERT_TRUE(run_preamble());

  ::testing::InSequence s;
  EXPECT_CALL(*varb, read(&mock_factory_, 0)).WillOnce(Return(1));
  EXPECT_CALL(*vara, read(&mock_factory_, 0)).WillOnce(Return(0));
  EXPECT_CALL(*varb, read(&mock_factory_, 0)).WillOnce(Return(1));
  EXPECT_CALL(*vara, write(&mock_factory_, 0, 1));
  
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(0, 1, 0));
}

TEST_F(VMTest, poly_assignment) {
  ASSERT_FALSE(compile("int a; bool b; a=b"));
  ASSERT_FALSE(compile("int a; bool b; b=a"));
}

TEST_F(VMTest, poly_assignment_ok) {
  ASSERT_TRUE(compile("int a=5; int b=3; a=b"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(3, 3));

  clear();

  ASSERT_TRUE(compile("bool a=True; bool b; b=a"));
  ASSERT_TRUE(run());
  EXPECT_THAT(get_op_stack(), ElementsAre(1, 1));
}


} // namespace logic
